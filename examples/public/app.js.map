{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///../lib/createElement.ts","webpack:///../lib/index.ts","webpack:///../lib/render.ts","webpack:///../node_modules/fp-ts/lib/Option.js","webpack:///../node_modules/fp-ts/lib/function.js","webpack:///../node_modules/fp-ts/lib/pipeable.js","webpack:///./index.tsx"],"names":[],"mappings":";QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;;;;AClFA,kGAAgD;AAInC,qBAAa,GACxB,UAAC,MAAc,EAAE,KAA6B;IAAE,kBAAkB;SAAlB,UAAkB,EAAlB,qBAAkB,EAAlB,IAAkB;QAAlB,iCAAkB;;IAChE,QAAC;QACC,MAAM;QACN,KAAK,EAAE,qBAAY,CAAC,KAAK,CAAC;QAC1B,QAAQ;KACT,CAAC;AAJF,CAIE,CAAC;;;;;;;;;;;;;;;;;;ACVP,4FAAgD;AAChD,wFAA8B;AAS9B,IAAM,QAAQ,GAAG;IACf,aAAa;CACd,CAAC;AAEW,mBAAW,GAAG;IACzB,MAAM;CACP,CAAC;AAEF,kBAAe,QAAQ,CAAC;;;;;;;;;;;;;;;AClBxB,IAAM,MAAM,GAAG,UAAC,IAAS,EAAE,MAAkB;IAAlB,sCAAkB;IAC3C,IAAM,OAAO,GAAG,QAAQ,CAAC,aAAa,CAAC,KAAK,CAAC,CAAC;IAC9C,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;IAClB,OAAO,CAAC,SAAS,GAAG,OAAO,CAAC;IAC5B,OAAO,OAAO,CAAC;AACjB,CAAC;AAED,kBAAe,MAAM,CAAC;;;;;;;;;;;;;ACPT;AACb;AACA;AACA,gDAAgD,OAAO;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,iBAAiB,mBAAO,CAAC,yDAAY;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,qBAAqB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,qBAAqB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,mBAAmB;AAC9B,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA,sDAAsD,EAAE;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,EAAE;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,mDAAmD;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,2BAA2B;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,yBAAyB;AACpC,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,0BAA0B;AACrC,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,wBAAwB;AACnC,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,2CAA2C;AACrE;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,mBAAmB;AAC9B,WAAW,WAAW;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,qDAAqD;AAClF;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,qBAAqB;AAChC,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,mDAAmD;AAC7E;AACA;AACA;AACA,yBAAyB,gDAAgD;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,uBAAuB;AAClC;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,4BAA4B;AACvC;AACA,aAAa;AACb,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,6BAA6B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,wCAAwC;AACnD,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,WAAW,WAAW,UAAU,sBAAsB,EAAE,EAAE;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,WAAW,WAAW,WAAW,EAAE,EAAE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,gEAAgE;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,iEAAiE;AAC9F;AACA;AACA;AACA;AACA;AACA,WAAW,oBAAoB;AAC/B,WAAW,WAAW;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,4FAA4F;AAC7H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,qBAAqB;AAChC,WAAW,YAAY;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,uFAAuF;AACzH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,gCAAgC;AAC3C,WAAW,eAAe;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,mFAAmF;AACpH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,yBAAyB,uBAAuB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,6BAA6B;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,4BAA4B,EAAE;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,4BAA4B;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,4BAA4B,EAAE;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,wBAAwB;AACnC,WAAW,eAAe;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,2EAA2E,EAAE;AAC9G;AACA;AACA;AACA;AACA,uBAAuB;AACvB,6BAA6B,UAAU;AACvC;AACA;AACA;AACA;AACA;AACA,2BAA2B,wDAAwD,EAAE;AACrF;AACA,4BAA4B,6FAA6F,EAAE;AAC3H,6BAA6B,kDAAkD,EAAE;AACjF,iCAAiC,0CAA0C,EAAE;AAC7E,2BAA2B,0BAA0B,6CAA6C,GAAG,EAAE;AACvG,sCAAsC,0CAA0C,EAAE;AAClF,4BAA4B;AAC5B;AACA,MAAM,EAAE;AACR,4BAA4B;AAC5B;AACA,MAAM,EAAE;AACR,uBAAuB,qBAAqB,EAAE;AAC9C,2BAA2B,gCAAgC,EAAE;AAC7D,8BAA8B,kDAAkD,EAAE;AAClF,4BAA4B,2CAA2C,EAAE;AACzE;AACA,qDAAqD;AACrD;AACA;AACA,SAAS,EAAE,EAAE;AACb;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL,iCAAiC,kDAAkD,EAAE;AACrF;AACA;AACA,0DAA0D,sBAAsB,EAAE;AAClF;AACA;AACA,KAAK;AACL,oCAAoC,2DAA2D,EAAE;AACjG,0BAA0B;AAC1B;AACA,MAAM,EAAE;AACR,wBAAwB;AACxB;AACA,6CAA6C;AAC7C;AACA;AACA,aAAa,EAAE,EAAE;AACjB,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,MAAM,EAAE;AACR,6BAA6B,qBAAqB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxmBa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,sBAAsB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,UAAU;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gBAAgB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA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","file":"app.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./index.tsx\");\n","import { fromNullable } from 'fp-ts/lib/Option';\nimport { Dict } from './types/common/collection';\nimport { Nullable } from './types/hkt/Nullable';\n\nexport const createElement =\n  (elType: string, props: Nullable<Dict<string>>, ...children: any[]) =>\n    ({\n      elType,\n      props: fromNullable(props),\n      children,\n    });\n","import { createElement } from './createElement';\nimport render from './render';\nimport Jsx from './jsx';\n\ndeclare global {\n  namespace JSX {\n    interface IntrinsicElements extends Jsx.IntrinsicElements { }\n  }\n}\n\nconst Bluetide = {\n  createElement,\n};\n\nexport const BluetideDOM = {\n  render\n};\n\nexport default Bluetide;\n","const render = (vdom: any, parent: any = null) => {\n  const element = document.createElement('div');\n  console.log(vdom);\n  element.innerText = 'pidor';\n  return element;\n}\n\nexport default render;\n","\"use strict\";\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar pipeable_1 = require(\"./pipeable\");\n/**\n * @since 2.0.0\n */\nexports.URI = 'Option';\n/**\n * @since 2.0.0\n */\nexports.none = { _tag: 'None' };\n/**\n * @since 2.0.0\n */\nfunction some(a) {\n    return { _tag: 'Some', value: a };\n}\nexports.some = some;\n/**\n * Returns `true` if the option is an instance of `Some`, `false` otherwise\n *\n * @example\n * import { some, none, isSome } from 'fp-ts/lib/Option'\n *\n * assert.strictEqual(isSome(some(1)), true)\n * assert.strictEqual(isSome(none), false)\n *\n * @since 2.0.0\n */\nfunction isSome(fa) {\n    return fa._tag === 'Some';\n}\nexports.isSome = isSome;\n/**\n * Returns `true` if the option is `None`, `false` otherwise\n *\n * @example\n * import { some, none, isNone } from 'fp-ts/lib/Option'\n *\n * assert.strictEqual(isNone(some(1)), false)\n * assert.strictEqual(isNone(none), true)\n *\n * @since 2.0.0\n */\nfunction isNone(fa) {\n    return fa._tag === 'None';\n}\nexports.isNone = isNone;\n/**\n * We can pattern match using the `fold` function\n *\n * @example\n * import { some, none, fold } from 'fp-ts/lib/Option'\n * import { pipe } from 'fp-ts/lib/pipeable'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     fold(() => 'a none', a => `a some containing ${a}`)\n *   ),\n *   'a some containing 1'\n * )\n *\n * assert.strictEqual(\n *   pipe(\n *     none,\n *     fold(() => 'a none', a => `a some containing ${a}`)\n *   ),\n *   'a none'\n * )\n *\n * @since 2.0.0\n */\nfunction fold(onNone, onSome) {\n    return function (ma) { return (isNone(ma) ? onNone() : onSome(ma.value)); };\n}\nexports.fold = fold;\n/**\n * Constructs a new `Option` from a nullable type. If the value is `null` or `undefined`, returns `None`, otherwise\n * returns the value wrapped in a `Some`\n *\n * @example\n * import { none, some, fromNullable } from 'fp-ts/lib/Option'\n *\n * assert.deepStrictEqual(fromNullable(undefined), none)\n * assert.deepStrictEqual(fromNullable(null), none)\n * assert.deepStrictEqual(fromNullable(1), some(1))\n *\n * @since 2.0.0\n */\nfunction fromNullable(a) {\n    return a == null ? exports.none : some(a);\n}\nexports.fromNullable = fromNullable;\n/**\n * Extracts the value out of the structure, if it exists. Otherwise returns `null`.\n *\n * @example\n * import { some, none, toNullable } from 'fp-ts/lib/Option'\n * import { pipe } from 'fp-ts/lib/pipeable'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     toNullable\n *   ),\n *   1\n * )\n * assert.strictEqual(\n *   pipe(\n *     none,\n *     toNullable\n *   ),\n *   null\n * )\n *\n * @since 2.0.0\n */\nfunction toNullable(ma) {\n    return isNone(ma) ? null : ma.value;\n}\nexports.toNullable = toNullable;\n/**\n * Extracts the value out of the structure, if it exists. Otherwise returns `undefined`.\n *\n * @example\n * import { some, none, toUndefined } from 'fp-ts/lib/Option'\n * import { pipe } from 'fp-ts/lib/pipeable'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     toUndefined\n *   ),\n *   1\n * )\n * assert.strictEqual(\n *   pipe(\n *     none,\n *     toUndefined\n *   ),\n *   undefined\n * )\n *\n * @since 2.0.0\n */\nfunction toUndefined(ma) {\n    return isNone(ma) ? undefined : ma.value;\n}\nexports.toUndefined = toUndefined;\n/**\n * Extracts the value out of the structure, if it exists. Otherwise returns the given default value\n *\n * @example\n * import { some, none, getOrElse } from 'fp-ts/lib/Option'\n * import { pipe } from 'fp-ts/lib/pipeable'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     getOrElse(() => 0)\n *   ),\n *   1\n * )\n * assert.strictEqual(\n *   pipe(\n *     none,\n *     getOrElse(() => 0)\n *   ),\n *   0\n * )\n *\n * @since 2.0.0\n */\nfunction getOrElse(onNone) {\n    return function (ma) { return (isNone(ma) ? onNone() : ma.value); };\n}\nexports.getOrElse = getOrElse;\n/**\n * Returns `true` if `ma` contains `a`\n *\n * @example\n * import { some, none, elem } from 'fp-ts/lib/Option'\n * import { eqNumber } from 'fp-ts/lib/Eq'\n *\n * assert.strictEqual(elem(eqNumber)(1, some(1)), true)\n * assert.strictEqual(elem(eqNumber)(2, some(1)), false)\n * assert.strictEqual(elem(eqNumber)(1, none), false)\n *\n * @since 2.0.0\n */\nfunction elem(E) {\n    return function (a, ma) { return (isNone(ma) ? false : E.equals(a, ma.value)); };\n}\nexports.elem = elem;\n/**\n * Returns `true` if the predicate is satisfied by the wrapped value\n *\n * @example\n * import { some, none, exists } from 'fp-ts/lib/Option'\n * import { pipe } from 'fp-ts/lib/pipeable'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     exists(n => n > 0)\n *   ),\n *   true\n * )\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     exists(n => n > 1)\n *   ),\n *   false\n * )\n * assert.strictEqual(\n *   pipe(\n *     none,\n *     exists(n => n > 0)\n *   ),\n *   false\n * )\n *\n * @since 2.0.0\n */\nfunction exists(predicate) {\n    return function (ma) { return (isNone(ma) ? false : predicate(ma.value)); };\n}\nexports.exists = exists;\nfunction fromPredicate(predicate) {\n    return function (a) { return (predicate(a) ? some(a) : exports.none); };\n}\nexports.fromPredicate = fromPredicate;\n/**\n * Transforms an exception into an `Option`. If `f` throws, returns `None`, otherwise returns the output wrapped in\n * `Some`\n *\n * @example\n * import { none, some, tryCatch } from 'fp-ts/lib/Option'\n *\n * assert.deepStrictEqual(\n *   tryCatch(() => {\n *     throw new Error()\n *   }),\n *   none\n * )\n * assert.deepStrictEqual(tryCatch(() => 1), some(1))\n *\n * @since 2.0.0\n */\nfunction tryCatch(f) {\n    try {\n        return some(f());\n    }\n    catch (e) {\n        return exports.none;\n    }\n}\nexports.tryCatch = tryCatch;\n/**\n * Returns an `E` value if possible\n *\n * @since 2.0.0\n */\nfunction getLeft(ma) {\n    return ma._tag === 'Right' ? exports.none : some(ma.left);\n}\nexports.getLeft = getLeft;\n/**\n * Returns an `A` value if possible\n *\n * @since 2.0.0\n */\nfunction getRight(ma) {\n    return ma._tag === 'Left' ? exports.none : some(ma.right);\n}\nexports.getRight = getRight;\n/**\n * Returns a `Refinement` (i.e. a custom type guard) from a `Option` returning function.\n * This function ensures that a custom type guard definition is type-safe.\n *\n * ```ts\n * import { some, none, getRefinement } from 'fp-ts/lib/Option'\n *\n * type A = { type: 'A' }\n * type B = { type: 'B' }\n * type C = A | B\n *\n * const isA = (c: C): c is A => c.type === 'B' // <= typo but typescript doesn't complain\n * const isA = getRefinement<C, A>(c => (c.type === 'B' ? some(c) : none)) // static error: Type '\"B\"' is not assignable to type '\"A\"'\n * ```\n *\n * @since 2.0.0\n */\nfunction getRefinement(getOption) {\n    return function (a) { return isSome(getOption(a)); };\n}\nexports.getRefinement = getRefinement;\n/**\n * This is `chain` + `fromNullable`, useful when working with optional values\n *\n * @example\n * import { some, none, fromNullable, mapNullable } from 'fp-ts/lib/Option'\n * import { pipe } from 'fp-ts/lib/pipeable'\n *\n * interface Employee {\n *   company?: {\n *     address?: {\n *       street?: {\n *         name?: string\n *       }\n *     }\n *   }\n * }\n *\n * const employee1: Employee = { company: { address: { street: { name: 'high street' } } } }\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     fromNullable(employee1.company),\n *     mapNullable(company => company.address),\n *     mapNullable(address => address.street),\n *     mapNullable(street => street.name)\n *   ),\n *   some('high street')\n * )\n *\n * const employee2: Employee = { company: { address: { street: {} } } }\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     fromNullable(employee2.company),\n *     mapNullable(company => company.address),\n *     mapNullable(address => address.street),\n *     mapNullable(street => street.name)\n *   ),\n *   none\n * )\n *\n * @since 2.0.0\n */\nfunction mapNullable(f) {\n    return function (ma) { return (isNone(ma) ? exports.none : fromNullable(f(ma.value))); };\n}\nexports.mapNullable = mapNullable;\n/**\n * @since 2.0.0\n */\nfunction getShow(S) {\n    return {\n        show: function (ma) { return (isNone(ma) ? 'none' : \"some(\" + S.show(ma.value) + \")\"); }\n    };\n}\nexports.getShow = getShow;\n/**\n * @example\n * import { none, some, getEq } from 'fp-ts/lib/Option'\n * import { eqNumber } from 'fp-ts/lib/Eq'\n *\n * const E = getEq(eqNumber)\n * assert.strictEqual(E.equals(none, none), true)\n * assert.strictEqual(E.equals(none, some(1)), false)\n * assert.strictEqual(E.equals(some(1), none), false)\n * assert.strictEqual(E.equals(some(1), some(2)), false)\n * assert.strictEqual(E.equals(some(1), some(1)), true)\n *\n * @since 2.0.0\n */\nfunction getEq(E) {\n    return {\n        equals: function (x, y) { return x === y || (isNone(x) ? isNone(y) : isNone(y) ? false : E.equals(x.value, y.value)); }\n    };\n}\nexports.getEq = getEq;\n/**\n * The `Ord` instance allows `Option` values to be compared with\n * `compare`, whenever there is an `Ord` instance for\n * the type the `Option` contains.\n *\n * `None` is considered to be less than any `Some` value.\n *\n *\n * @example\n * import { none, some, getOrd } from 'fp-ts/lib/Option'\n * import { ordNumber } from 'fp-ts/lib/Ord'\n *\n * const O = getOrd(ordNumber)\n * assert.strictEqual(O.compare(none, none), 0)\n * assert.strictEqual(O.compare(none, some(1)), -1)\n * assert.strictEqual(O.compare(some(1), none), 1)\n * assert.strictEqual(O.compare(some(1), some(2)), -1)\n * assert.strictEqual(O.compare(some(1), some(1)), 0)\n *\n * @since 2.0.0\n */\nfunction getOrd(O) {\n    return {\n        equals: getEq(O).equals,\n        compare: function (x, y) { return (x === y ? 0 : isSome(x) ? (isSome(y) ? O.compare(x.value, y.value) : 1) : -1); }\n    };\n}\nexports.getOrd = getOrd;\n/**\n * `Apply` semigroup\n *\n * | x       | y       | concat(x, y)       |\n * | ------- | ------- | ------------------ |\n * | none    | none    | none               |\n * | some(a) | none    | none               |\n * | none    | some(a) | none               |\n * | some(a) | some(b) | some(concat(a, b)) |\n *\n * @example\n * import { getApplySemigroup, some, none } from 'fp-ts/lib/Option'\n * import { semigroupSum } from 'fp-ts/lib/Semigroup'\n *\n * const S = getApplySemigroup(semigroupSum)\n * assert.deepStrictEqual(S.concat(none, none), none)\n * assert.deepStrictEqual(S.concat(some(1), none), none)\n * assert.deepStrictEqual(S.concat(none, some(1)), none)\n * assert.deepStrictEqual(S.concat(some(1), some(2)), some(3))\n *\n * @since 2.0.0\n */\nfunction getApplySemigroup(S) {\n    return {\n        concat: function (x, y) { return (isSome(x) && isSome(y) ? some(S.concat(x.value, y.value)) : exports.none); }\n    };\n}\nexports.getApplySemigroup = getApplySemigroup;\n/**\n * @since 2.0.0\n */\nfunction getApplyMonoid(M) {\n    return __assign({}, getApplySemigroup(M), { empty: some(M.empty) });\n}\nexports.getApplyMonoid = getApplyMonoid;\n/**\n * Monoid returning the left-most non-`None` value\n *\n * | x       | y       | concat(x, y) |\n * | ------- | ------- | ------------ |\n * | none    | none    | none         |\n * | some(a) | none    | some(a)      |\n * | none    | some(a) | some(a)      |\n * | some(a) | some(b) | some(a)      |\n *\n * @example\n * import { getFirstMonoid, some, none } from 'fp-ts/lib/Option'\n *\n * const M = getFirstMonoid<number>()\n * assert.deepStrictEqual(M.concat(none, none), none)\n * assert.deepStrictEqual(M.concat(some(1), none), some(1))\n * assert.deepStrictEqual(M.concat(none, some(1)), some(1))\n * assert.deepStrictEqual(M.concat(some(1), some(2)), some(1))\n *\n * @since 2.0.0\n */\nfunction getFirstMonoid() {\n    return {\n        concat: function (x, y) { return (isNone(x) ? y : x); },\n        empty: exports.none\n    };\n}\nexports.getFirstMonoid = getFirstMonoid;\n/**\n * Monoid returning the right-most non-`None` value\n *\n * | x       | y       | concat(x, y) |\n * | ------- | ------- | ------------ |\n * | none    | none    | none         |\n * | some(a) | none    | some(a)      |\n * | none    | some(a) | some(a)      |\n * | some(a) | some(b) | some(b)      |\n *\n * @example\n * import { getLastMonoid, some, none } from 'fp-ts/lib/Option'\n *\n * const M = getLastMonoid<number>()\n * assert.deepStrictEqual(M.concat(none, none), none)\n * assert.deepStrictEqual(M.concat(some(1), none), some(1))\n * assert.deepStrictEqual(M.concat(none, some(1)), some(1))\n * assert.deepStrictEqual(M.concat(some(1), some(2)), some(2))\n *\n * @since 2.0.0\n */\nfunction getLastMonoid() {\n    return {\n        concat: function (x, y) { return (isNone(y) ? x : y); },\n        empty: exports.none\n    };\n}\nexports.getLastMonoid = getLastMonoid;\n/**\n * Monoid returning the left-most non-`None` value. If both operands are `Some`s then the inner values are\n * appended using the provided `Semigroup`\n *\n * | x       | y       | concat(x, y)       |\n * | ------- | ------- | ------------------ |\n * | none    | none    | none               |\n * | some(a) | none    | some(a)            |\n * | none    | some(a) | some(a)            |\n * | some(a) | some(b) | some(concat(a, b)) |\n *\n * @example\n * import { getMonoid, some, none } from 'fp-ts/lib/Option'\n * import { semigroupSum } from 'fp-ts/lib/Semigroup'\n *\n * const M = getMonoid(semigroupSum)\n * assert.deepStrictEqual(M.concat(none, none), none)\n * assert.deepStrictEqual(M.concat(some(1), none), some(1))\n * assert.deepStrictEqual(M.concat(none, some(1)), some(1))\n * assert.deepStrictEqual(M.concat(some(1), some(2)), some(3))\n *\n * @since 2.0.0\n */\nfunction getMonoid(S) {\n    return {\n        concat: function (x, y) { return (isNone(x) ? y : isNone(y) ? x : some(S.concat(x.value, y.value))); },\n        empty: exports.none\n    };\n}\nexports.getMonoid = getMonoid;\nvar defaultSeparate = { left: exports.none, right: exports.none };\nvar identity = function (a) { return a; };\n/**\n * @since 2.0.0\n */\nexports.option = {\n    URI: exports.URI,\n    map: function (ma, f) { return (isNone(ma) ? exports.none : some(f(ma.value))); },\n    of: some,\n    ap: function (mab, ma) { return (isNone(mab) ? exports.none : isNone(ma) ? exports.none : some(mab.value(ma.value))); },\n    chain: function (ma, f) { return (isNone(ma) ? exports.none : f(ma.value)); },\n    reduce: function (fa, b, f) { return (isNone(fa) ? b : f(b, fa.value)); },\n    foldMap: function (M) { return function (fa, f) { return (isNone(fa) ? M.empty : f(fa.value)); }; },\n    reduceRight: function (fa, b, f) { return (isNone(fa) ? b : f(fa.value, b)); },\n    traverse: function (F) { return function (ta, f) {\n        return isNone(ta) ? F.of(exports.none) : F.map(f(ta.value), some);\n    }; },\n    sequence: function (F) { return function (ta) {\n        return isNone(ta) ? F.of(exports.none) : F.map(ta.value, some);\n    }; },\n    zero: function () { return exports.none; },\n    alt: function (ma, f) { return (isNone(ma) ? f() : ma); },\n    extend: function (wa, f) { return (isNone(wa) ? exports.none : some(f(wa))); },\n    compact: function (ma) { return exports.option.chain(ma, identity); },\n    separate: function (ma) {\n        var o = exports.option.map(ma, function (e) { return ({\n            left: getLeft(e),\n            right: getRight(e)\n        }); });\n        return isNone(o) ? defaultSeparate : o.value;\n    },\n    filter: function (fa, predicate) {\n        return isNone(fa) ? exports.none : predicate(fa.value) ? fa : exports.none;\n    },\n    filterMap: function (ma, f) { return (isNone(ma) ? exports.none : f(ma.value)); },\n    partition: function (fa, predicate) {\n        return {\n            left: exports.option.filter(fa, function (a) { return !predicate(a); }),\n            right: exports.option.filter(fa, predicate)\n        };\n    },\n    partitionMap: function (fa, f) { return exports.option.separate(exports.option.map(fa, f)); },\n    wither: function (F) { return function (fa, f) {\n        return isNone(fa) ? F.of(exports.none) : f(fa.value);\n    }; },\n    wilt: function (F) { return function (fa, f) {\n        var o = exports.option.map(fa, function (a) {\n            return F.map(f(a), function (e) { return ({\n                left: getLeft(e),\n                right: getRight(e)\n            }); });\n        });\n        return isNone(o)\n            ? F.of({\n                left: exports.none,\n                right: exports.none\n            })\n            : o.value;\n    }; },\n    throwError: function () { return exports.none; }\n};\nvar _a = pipeable_1.pipeable(exports.option), alt = _a.alt, ap = _a.ap, apFirst = _a.apFirst, apSecond = _a.apSecond, chain = _a.chain, chainFirst = _a.chainFirst, duplicate = _a.duplicate, extend = _a.extend, filter = _a.filter, filterMap = _a.filterMap, flatten = _a.flatten, foldMap = _a.foldMap, map = _a.map, partition = _a.partition, partitionMap = _a.partitionMap, reduce = _a.reduce, reduceRight = _a.reduceRight, compact = _a.compact, separate = _a.separate, fromEither = _a.fromEither;\nexports.alt = alt;\nexports.ap = ap;\nexports.apFirst = apFirst;\nexports.apSecond = apSecond;\nexports.chain = chain;\nexports.chainFirst = chainFirst;\nexports.duplicate = duplicate;\nexports.extend = extend;\nexports.filter = filter;\nexports.filterMap = filterMap;\nexports.flatten = flatten;\nexports.foldMap = foldMap;\nexports.map = map;\nexports.partition = partition;\nexports.partitionMap = partitionMap;\nexports.reduce = reduce;\nexports.reduceRight = reduceRight;\nexports.compact = compact;\nexports.separate = separate;\nexports.fromEither = fromEither;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @since 2.0.0\n */\nfunction identity(a) {\n    return a;\n}\nexports.identity = identity;\n/**\n * @since 2.0.0\n */\nexports.unsafeCoerce = identity;\n/**\n * @since 2.0.0\n */\nfunction not(predicate) {\n    return function (a) { return !predicate(a); };\n}\nexports.not = not;\n/**\n * @since 2.0.0\n */\nfunction constant(a) {\n    return function () { return a; };\n}\nexports.constant = constant;\n/**\n * A thunk that returns always `true`\n *\n * @since 2.0.0\n */\nexports.constTrue = function () {\n    return true;\n};\n/**\n * A thunk that returns always `false`\n *\n * @since 2.0.0\n */\nexports.constFalse = function () {\n    return false;\n};\n/**\n * A thunk that returns always `null`\n *\n * @since 2.0.0\n */\nexports.constNull = function () {\n    return null;\n};\n/**\n * A thunk that returns always `undefined`\n *\n * @since 2.0.0\n */\nexports.constUndefined = function () {\n    return;\n};\n/**\n * A thunk that returns always `void`\n *\n * @since 2.0.0\n */\nexports.constVoid = function () {\n    return;\n};\n/**\n * Flips the order of the arguments of a function of two arguments.\n *\n * @since 2.0.0\n */\nfunction flip(f) {\n    return function (b, a) { return f(a, b); };\n}\nexports.flip = flip;\nfunction flow(ab, bc, cd, de, ef, fg, gh, hi, ij) {\n    switch (arguments.length) {\n        case 1:\n            return ab;\n        case 2:\n            return function () {\n                return bc(ab.apply(this, arguments));\n            };\n        case 3:\n            return function () {\n                return cd(bc(ab.apply(this, arguments)));\n            };\n        case 4:\n            return function () {\n                return de(cd(bc(ab.apply(this, arguments))));\n            };\n        case 5:\n            return function () {\n                return ef(de(cd(bc(ab.apply(this, arguments)))));\n            };\n        case 6:\n            return function () {\n                return fg(ef(de(cd(bc(ab.apply(this, arguments))))));\n            };\n        case 7:\n            return function () {\n                return gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))));\n            };\n        case 8:\n            return function () {\n                return hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments))))))));\n            };\n        case 9:\n            return function () {\n                return ij(hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))))));\n            };\n    }\n}\nexports.flow = flow;\n/**\n * @since 2.0.0\n */\nfunction tuple() {\n    var t = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        t[_i] = arguments[_i];\n    }\n    return t;\n}\nexports.tuple = tuple;\n/**\n * @since 2.0.0\n */\nfunction increment(n) {\n    return n + 1;\n}\nexports.increment = increment;\n/**\n * @since 2.0.0\n */\nfunction decrement(n) {\n    return n - 1;\n}\nexports.decrement = decrement;\n/**\n * @since 2.0.0\n */\nfunction absurd(_) {\n    throw new Error('Called `absurd` function which should be uncallable');\n}\nexports.absurd = absurd;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar function_1 = require(\"./function\");\nfunction pipe(a, ab, bc, cd, de, ef, fg, gh, hi, ij) {\n    switch (arguments.length) {\n        case 1:\n            return a;\n        case 2:\n            return ab(a);\n        case 3:\n            return bc(ab(a));\n        case 4:\n            return cd(bc(ab(a)));\n        case 5:\n            return de(cd(bc(ab(a))));\n        case 6:\n            return ef(de(cd(bc(ab(a)))));\n        case 7:\n            return fg(ef(de(cd(bc(ab(a))))));\n        case 8:\n            return gh(fg(ef(de(cd(bc(ab(a)))))));\n        case 9:\n            return hi(gh(fg(ef(de(cd(bc(ab(a))))))));\n        case 10:\n            return ij(hi(gh(fg(ef(de(cd(bc(ab(a)))))))));\n    }\n}\nexports.pipe = pipe;\nvar isFunctor = function (I) { return typeof I.map === 'function'; };\nvar isContravariant = function (I) { return typeof I.contramap === 'function'; };\nvar isFunctorWithIndex = function (I) { return typeof I.mapWithIndex === 'function'; };\nvar isApply = function (I) { return typeof I.ap === 'function'; };\nvar isChain = function (I) { return typeof I.chain === 'function'; };\nvar isBifunctor = function (I) { return typeof I.bimap === 'function'; };\nvar isExtend = function (I) { return typeof I.extend === 'function'; };\nvar isFoldable = function (I) { return typeof I.reduce === 'function'; };\nvar isFoldableWithIndex = function (I) { return typeof I.reduceWithIndex === 'function'; };\nvar isAlt = function (I) { return typeof I.alt === 'function'; };\nvar isCompactable = function (I) { return typeof I.compact === 'function'; };\nvar isFilterable = function (I) { return typeof I.filter === 'function'; };\nvar isFilterableWithIndex = function (I) {\n    return typeof I.filterWithIndex === 'function';\n};\nvar isProfunctor = function (I) { return typeof I.promap === 'function'; };\nvar isSemigroupoid = function (I) { return typeof I.compose === 'function'; };\nvar isMonadThrow = function (I) { return typeof I.throwError === 'function'; };\nfunction pipeable(I) {\n    var r = {};\n    if (isFunctor(I)) {\n        var map = function (f) { return function (fa) { return I.map(fa, f); }; };\n        r.map = map;\n    }\n    if (isContravariant(I)) {\n        var contramap = function (f) { return function (fa) { return I.contramap(fa, f); }; };\n        r.contramap = contramap;\n    }\n    if (isFunctorWithIndex(I)) {\n        var mapWithIndex = function (f) { return function (fa) { return I.mapWithIndex(fa, f); }; };\n        r.mapWithIndex = mapWithIndex;\n    }\n    if (isApply(I)) {\n        var ap = function (fa) { return function (fab) { return I.ap(fab, fa); }; };\n        var apFirst = function (fb) { return function (fa) { return I.ap(I.map(fa, function (a) { return function () { return a; }; }), fb); }; };\n        r.ap = ap;\n        r.apFirst = apFirst;\n        r.apSecond = function (fb) { return function (fa) { return I.ap(I.map(fa, function () { return function (b) { return b; }; }), fb); }; };\n    }\n    if (isChain(I)) {\n        var chain = function (f) { return function (ma) { return I.chain(ma, f); }; };\n        var chainFirst = function (f) { return function (ma) { return I.chain(ma, function (a) { return I.map(f(a), function () { return a; }); }); }; };\n        var flatten = function (mma) { return I.chain(mma, function_1.identity); };\n        r.chain = chain;\n        r.chainFirst = chainFirst;\n        r.flatten = flatten;\n    }\n    if (isBifunctor(I)) {\n        var bimap = function (f, g) { return function (fa) { return I.bimap(fa, f, g); }; };\n        var mapLeft = function (f) { return function (fa) { return I.mapLeft(fa, f); }; };\n        r.bimap = bimap;\n        r.mapLeft = mapLeft;\n    }\n    if (isExtend(I)) {\n        var extend = function (f) { return function (wa) { return I.extend(wa, f); }; };\n        var duplicate = function (wa) { return I.extend(wa, function_1.identity); };\n        r.extend = extend;\n        r.duplicate = duplicate;\n    }\n    if (isFoldable(I)) {\n        var reduce = function (b, f) { return function (fa) { return I.reduce(fa, b, f); }; };\n        var foldMap = function (M) {\n            var foldMapM = I.foldMap(M);\n            return function (f) { return function (fa) { return foldMapM(fa, f); }; };\n        };\n        var reduceRight = function (b, f) { return function (fa) { return I.reduceRight(fa, b, f); }; };\n        r.reduce = reduce;\n        r.foldMap = foldMap;\n        r.reduceRight = reduceRight;\n    }\n    if (isFoldableWithIndex(I)) {\n        var reduceWithIndex = function (b, f) { return function (fa) {\n            return I.reduceWithIndex(fa, b, f);\n        }; };\n        var foldMapWithIndex = function (M) {\n            var foldMapM = I.foldMapWithIndex(M);\n            return function (f) { return function (fa) { return foldMapM(fa, f); }; };\n        };\n        var reduceRightWithIndex = function (b, f) { return function (fa) {\n            return I.reduceRightWithIndex(fa, b, f);\n        }; };\n        r.reduceWithIndex = reduceWithIndex;\n        r.foldMapWithIndex = foldMapWithIndex;\n        r.reduceRightWithIndex = reduceRightWithIndex;\n    }\n    if (isAlt(I)) {\n        var alt = function (that) { return function (fa) { return I.alt(fa, that); }; };\n        r.alt = alt;\n    }\n    if (isCompactable(I)) {\n        r.compact = I.compact;\n        r.separate = I.separate;\n    }\n    if (isFilterable(I)) {\n        var filter = function (predicate) { return function (fa) {\n            return I.filter(fa, predicate);\n        }; };\n        var filterMap = function (f) { return function (fa) { return I.filterMap(fa, f); }; };\n        var partition = function (predicate) { return function (fa) {\n            return I.partition(fa, predicate);\n        }; };\n        var partitionMap = function (f) { return function (fa) { return I.partitionMap(fa, f); }; };\n        r.filter = filter;\n        r.filterMap = filterMap;\n        r.partition = partition;\n        r.partitionMap = partitionMap;\n    }\n    if (isFilterableWithIndex(I)) {\n        var filterWithIndex = function (predicateWithIndex) { return function (fa) { return I.filterWithIndex(fa, predicateWithIndex); }; };\n        var filterMapWithIndex = function (f) { return function (fa) {\n            return I.filterMapWithIndex(fa, f);\n        }; };\n        var partitionWithIndex = function (predicateWithIndex) { return function (fa) { return I.partitionWithIndex(fa, predicateWithIndex); }; };\n        var partitionMapWithIndex = function (f) { return function (fa) {\n            return I.partitionMapWithIndex(fa, f);\n        }; };\n        r.filterWithIndex = filterWithIndex;\n        r.filterMapWithIndex = filterMapWithIndex;\n        r.partitionWithIndex = partitionWithIndex;\n        r.partitionMapWithIndex = partitionMapWithIndex;\n    }\n    if (isProfunctor(I)) {\n        var promap = function (f, g) { return function (fa) { return I.promap(fa, f, g); }; };\n        r.promap = promap;\n    }\n    if (isSemigroupoid(I)) {\n        var compose = function (that) { return function (fa) {\n            return I.compose(fa, that);\n        }; };\n        r.compose = compose;\n    }\n    if (isMonadThrow(I)) {\n        var fromOption = function (onNone) { return function (ma) {\n            return ma._tag === 'None' ? I.throwError(onNone()) : I.of(ma.value);\n        }; };\n        var fromEither = function (ma) {\n            return ma._tag === 'Left' ? I.throwError(ma.left) : I.of(ma.right);\n        };\n        var fromPredicate = function (predicate, onFalse) { return function (a) { return (predicate(a) ? I.of(a) : I.throwError(onFalse(a))); }; };\n        var filterOrElse = function (predicate, onFalse) { return function (ma) { return I.chain(ma, function (a) { return (predicate(a) ? I.of(a) : I.throwError(onFalse(a))); }); }; };\n        r.fromOption = fromOption;\n        r.fromEither = fromEither;\n        r.fromPredicate = fromPredicate;\n        r.filterOrElse = filterOrElse;\n    }\n    return r;\n}\nexports.pipeable = pipeable;\n","/* @jsx Bluetide.createElement */\nimport Bluetide, { BluetideDOM } from '../lib';\nimport { Props } from '../lib/types/dom';\n\nconst El = (props: {}) => {\n  return (\n    <div>\n      Pidor\n    </div>\n  );\n};\n\nBluetideDOM.render(<El />);\n"],"sourceRoot":""}